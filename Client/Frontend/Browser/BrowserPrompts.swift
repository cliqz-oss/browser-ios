/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

import Foundation
import WebKit

@objc protocol JSPromptAlertControllerDelegate: class {
    func promptAlertControllerDidDismiss(alertController: JSPromptAlertController)
}

/// A simple version of UIAlertController that attaches a delegate to the viewDidDisappear method
/// to allow forwarding the event. The reason this is needed for prompts from Javascript is we
/// need to invoke the completionHandler passed to us from the WKWebView delegate or else
/// a runtime exception is thrown.
class JSPromptAlertController: UIAlertController {
    var alertInfo: JSAlertInfo?

    weak var delegate: JSPromptAlertControllerDelegate?

    override func viewDidDisappear(animated: Bool) {
        super.viewDidDisappear(animated)
        alertInfo?.alertWillDismiss()
        delegate?.promptAlertControllerDidDismiss(self)
    }
}

/**
 *  An JSAlertInfo is used to store information about an alert we want to show either immediately or later.
 *  Since alerts are generated by web pages and have no upper limit it would be unwise to allocate a
 *  UIAlertController instance for each generated prompt which could potentially be queued in the background.
 *  Instead, the JSAlertInfo structure retains the relevant data needed for the prompt along with a copy
 *  of the provided completionHandler to let us generate the UIAlertController when needed.
 */
protocol JSAlertInfo {

    /**
     * A word about this mutating keyword here. These prompts should be calling their completion handlers when
     * the prompt is actually dismissed - not when the user selects an option. Ideally this would be handled 
     * inside the JSPromptAlertController subclass in the viewDidDisappear callback but UIAlertController 
     * was built to not be subclassed. Instead, when allocate the JSPromptAlertController we pass along a
     * reference to the alertInfo structure and manipulate the required state from the action handlers.
     */
    mutating func alertController() -> JSPromptAlertController
    func alertWillDismiss()
    func cancel()
}

struct MessageAlert: JSAlertInfo {
    let message: String
    let frame: WKFrameInfo
    let completionHandler: () -> Void

    mutating func alertController() -> JSPromptAlertController {
        let alertController = JSPromptAlertController(title: titleForJavaScriptPanelInitiatedByFrame(frame),
            message: message,
            preferredStyle: UIAlertControllerStyle.Alert)
        alertController.addAction(UIAlertAction(title: UIConstants.OKString, style: UIAlertActionStyle.Default, handler: nil))
        alertController.alertInfo = self
        return alertController
    }

    func alertWillDismiss() {
        completionHandler()
    }

    func cancel() {
        completionHandler()
    }
}

struct ConfirmPanelAlert: JSAlertInfo {
    let message: String
    let frame: WKFrameInfo
    let completionHandler: (Bool) -> Void

    var didConfirm: Bool = false

    init(message: String, frame: WKFrameInfo, completionHandler: (Bool) -> Void) {
        self.message = message
        self.frame = frame
        self.completionHandler = completionHandler
    }

    mutating func alertController() -> JSPromptAlertController {
        // Show JavaScript confirm dialogs.
        let alertController = JSPromptAlertController(title: titleForJavaScriptPanelInitiatedByFrame(frame), message: message, preferredStyle: UIAlertControllerStyle.Alert)
        alertController.addAction(UIAlertAction(title: UIConstants.OKString, style: UIAlertActionStyle.Default, handler: { _ in
            self.didConfirm = true
        }))
        alertController.addAction(UIAlertAction(title: UIConstants.CancelString, style: UIAlertActionStyle.Cancel, handler: nil))
        alertController.alertInfo = self
        return alertController
    }

    func alertWillDismiss() {
        completionHandler(didConfirm)
    }

    func cancel() {
        completionHandler(false)
    }
}

struct TextInputAlert: JSAlertInfo {
    let message: String
    let frame: WKFrameInfo
    let completionHandler: (String?) -> Void
    let defaultText: String?

    var input: UITextField!

    init(message: String, frame: WKFrameInfo, completionHandler: (String?) -> Void, defaultText: String?) {
        self.message = message
        self.frame = frame
        self.completionHandler = completionHandler
        self.defaultText = defaultText
    }

    mutating func alertController() -> JSPromptAlertController {
        let alertController = JSPromptAlertController(title: titleForJavaScriptPanelInitiatedByFrame(frame), message: message, preferredStyle: UIAlertControllerStyle.Alert)
        alertController.addTextFieldWithConfigurationHandler({ (textField: UITextField) in
            self.input = textField
            self.input.text = self.defaultText
        })
        alertController.addAction(UIAlertAction(title: UIConstants.OKString, style: UIAlertActionStyle.Default, handler: nil))
        alertController.addAction(UIAlertAction(title: UIConstants.CancelString, style: UIAlertActionStyle.Cancel, handler: nil))
        alertController.alertInfo = self
        return alertController
    }

    func alertWillDismiss() {
        completionHandler(input.text)
    }

    func cancel() {
        completionHandler(nil)
    }
}

/// Show a title for a JavaScript Panel (alert) based on the WKFrameInfo. On iOS9 we will use the new securityOrigin
/// and on iOS 8 we will fall back to the request URL. If the request URL is nil, which happens for JavaScript pages,
/// we fall back to "JavaScript" as a title.
private func titleForJavaScriptPanelInitiatedByFrame(frame: WKFrameInfo) -> String {
    var title: String = "JavaScript"
    if #available(iOS 9, *) {
        title = "\(frame.securityOrigin.`protocol`)://\(frame.securityOrigin.host)"
        if frame.securityOrigin.port != 0 {
            title += ":\(frame.securityOrigin.port)"
        }
    } else {
        if let url = frame.request.URL {
            title = "\(url.scheme)://\(url.hostPort))"
        }
    }
    return title
}
